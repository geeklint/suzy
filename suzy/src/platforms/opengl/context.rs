/* SPDX-License-Identifier: (Apache-2.0 OR MIT OR Zlib) */
/* Copyright Â© 2021 Violet Leonard */

#![allow(missing_docs)]

use std::rc::Rc;

use super::{mask::Mask, stdshaders::Shaders, texture::TextureCache};

pub const DEBUG: bool = option_env!("SUZY_GL_DEBUG").is_some();

pub mod bindings {
    #![allow(bare_trait_objects)]
    #![allow(
        clippy::too_many_arguments,
        clippy::unused_unit,
        clippy::upper_case_acronyms,
        clippy::missing_safety_doc,
        clippy::missing_transmute_annotations,
        clippy::manual_non_exhaustive
    )]

    // This file was generated by the gl_generator crate, but is included
    // statically for performance reasons

    include!("include/opengl_bindings.rs");
}

pub mod short_consts {
    const fn enum_to_u16(val: super::bindings::types::GLenum) -> u16 {
        assert!((val & 0xFFFF) == val, "GLenum was outside the range of u16");
        val as u16
    }

    pub const ALPHA: u16 = enum_to_u16(super::bindings::ALPHA);
    pub const CLAMP_TO_EDGE: u16 = enum_to_u16(super::bindings::CLAMP_TO_EDGE);
    pub const LINEAR: u16 = enum_to_u16(super::bindings::LINEAR);
    pub const LUMINANCE: u16 = enum_to_u16(super::bindings::LUMINANCE);
    pub const LUMINANCE_ALPHA: u16 =
        enum_to_u16(super::bindings::LUMINANCE_ALPHA);
    pub const NEAREST: u16 = enum_to_u16(super::bindings::NEAREST);
    pub const RGB: u16 = enum_to_u16(super::bindings::RGB);
    pub const RGBA: u16 = enum_to_u16(super::bindings::RGBA);
}

pub type OpenGlBindings = bindings::Gles2;

pub struct OpenGlContext {
    // must be first so it drops first, avoding UAF
    pub(super) bindings: Rc<OpenGlBindings>,
    #[expect(unused)]
    pub(super) extensions: Extensions,
    pub(super) shaders: Shaders,
    pub(super) texture_cache: TextureCache,
    pub(super) mask: Mask,
    pub(super) buffers: Vec<bindings::types::GLuint>,
}

impl OpenGlContext {
    pub fn new<F>(loader: F) -> Self
    where
        F: FnMut(&str) -> *const std::ffi::c_void,
    {
        let ptr = Rc::new(OpenGlBindings::load_with(loader));
        if DEBUG && ptr.DebugMessageCallback.is_loaded() {
            unsafe {
                ptr.Enable(bindings::DEBUG_OUTPUT);
                ptr.DebugMessageCallback(
                    Some(Self::message_callback),
                    std::ptr::null(),
                );
            }
        }
        let mut extensions = Extensions::default();
        let ext_cstr = unsafe {
            let p = ptr.GetString(bindings::EXTENSIONS);
            assert!(!p.is_null());
            std::ffi::CStr::from_ptr(p.cast())
        };
        for ext in ext_cstr
            .to_str()
            .expect("OpenGL extension string should be valid unicode")
            .split_whitespace()
        {
            match ext {
                "GL_OES_standard_derivatives" => {
                    extensions.standard_derivatives = true;
                }
                "GL_EXT_blend_func_extended" => {
                    extensions.blend_func_extended = true;
                }
                "GL_OES_compressed_ETC1_RGB8_texture" => {
                    extensions.compressed_etc1_rgb8_texture = true;
                }
                _ => {}
            }
        }
        let shaders = Shaders::new(&ptr).expect("Failed to compile shaders");
        let mask = Mask::new(&ptr);
        Self {
            bindings: ptr,
            extensions,
            shaders,
            texture_cache: TextureCache::default(),
            mask,
            buffers: Vec::new(),
        }
    }

    pub fn run_texture_populators(&mut self) {
        self.texture_cache.run_populators(&self.bindings);
    }

    #[allow(clippy::print_stdout)]
    extern "system" fn message_callback(
        _source: bindings::types::GLenum,
        _gltype: bindings::types::GLenum,
        _id: bindings::types::GLuint,
        _severity: bindings::types::GLenum,
        length: bindings::types::GLsizei,
        message: *const bindings::types::GLchar,
        _user_param: *mut std::ffi::c_void,
    ) {
        use std::convert::TryInto;
        let length = length.try_into().unwrap_or(usize::MAX);
        let data =
            unsafe { std::slice::from_raw_parts(message.cast(), length) };
        println!("{}", String::from_utf8_lossy(data));
    }
}

#[derive(Clone, Copy, Debug, Default)]
pub struct Extensions {
    blend_func_extended: bool,
    standard_derivatives: bool,
    compressed_etc1_rgb8_texture: bool,
}
